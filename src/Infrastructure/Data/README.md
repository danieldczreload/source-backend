# Database Layer

This folder contains the Entity Framework Core configuration and SQL Server database access.

## Structure

- **ApplicationDbContext.cs**: Main application DbContext
- **Configurations/**: Entity configurations using Fluent API
- **Migrations/**: Database migrations generated by EF Core

## Configuration

### Connection String

The connection string is stored securely:

1. **Local Development**: Uses `user-secrets`
   ```bash
   dotnet user-secrets set "ConnectionStrings:DefaultConnection" "your-connection-string" --project src/Web/SourceBackend.Web.csproj
   ```

2. **Production**: Configure via environment variable or Azure App Configuration
   - Environment variable: `ConnectionStrings__DefaultConnection`
   - Or configure in hosting service (Azure, AWS, etc.)

3. **appsettings.json**: Contains a placeholder (DO NOT commit real secrets)

### Verify Current Connection String

```bash
dotnet user-secrets list --project src/Web/SourceBackend.Web.csproj
```

## Creating Entities

### 1. Create the Entity Class

Create your entity in `src/Core/` (or appropriate location):

```csharp
namespace SourceBackend.Core.Entities;

public sealed class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public DateTimeOffset CreatedAt { get; set; }
}
```

### 2. Create Entity Configuration

Create a file in `src/Infrastructure/Data/Configurations/`:

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using SourceBackend.Core.Entities;

namespace SourceBackend.Infrastructure.Data.Configurations;

public sealed class ProductConfiguration : IEntityTypeConfiguration<Product>
{
    public void Configure(EntityTypeBuilder<Product> builder)
    {
        builder.ToTable("Products");
        
        builder.HasKey(p => p.Id);
        
        builder.Property(p => p.Name)
            .IsRequired()
            .HasMaxLength(200);
        
        builder.Property(p => p.Price)
            .HasPrecision(18, 2);
        
        builder.Property(p => p.CreatedAt)
            .IsRequired();
    }
}
```

### 3. Add DbSet to Context

In `ApplicationDbContext.cs`:

```csharp
public DbSet<Product> Products => Set<Product>();
```

## Migrations

### Create a New Migration

```bash
# From project root
dotnet ef migrations add MigrationName --project src/Infrastructure/SourceBackend.Infrastructure.csproj --startup-project src/Web/SourceBackend.Web.csproj
```

### Apply Migrations to Database

```bash
# Update to latest migration
dotnet ef database update --project src/Infrastructure/SourceBackend.Infrastructure.csproj --startup-project src/Web/SourceBackend.Web.csproj

# Update to specific migration
dotnet ef database update MigrationName --project src/Infrastructure/SourceBackend.Infrastructure.csproj --startup-project src/Web/SourceBackend.Web.csproj

# Rollback (revert to previous migration)
dotnet ef database update PreviousMigrationName --project src/Infrastructure/SourceBackend.Infrastructure.csproj --startup-project src/Web/SourceBackend.Web.csproj
```

### View Migration SQL

```bash
dotnet ef migrations script --project src/Infrastructure/SourceBackend.Infrastructure.csproj --startup-project src/Web/SourceBackend.Web.csproj
```

### Remove Last Migration

```bash
dotnet ef migrations remove --project src/Infrastructure/SourceBackend.Infrastructure.csproj --startup-project src/Web/SourceBackend.Web.csproj
```

## Database Usage

### Direct DbContext Approach (Recommended - KISS/YAGNI)

EF Core is already an abstraction over the database. DbContext works as Unit of Work and DbSets as repositories.

**Inject `ApplicationDbContext` directly in your handlers:**

#### Queries (Read)

```csharp
// Core/Features/Products/Queries/GetProducts.cs
namespace SourceBackend.Core.Features.Products.Queries;

public static class GetProducts
{
    public sealed record Query(decimal MinPrice);
    public sealed record Result(IReadOnlyList<ProductDto> Products);
    public sealed record ProductDto(int Id, string Name, decimal Price);

    public sealed class Handler(ApplicationDbContext db)
    {
        public async Task<Result> Handle(Query q, CancellationToken ct)
        {
            // Read and project directly to DTO
            var products = await db.Products
                .AsNoTracking()  // Important: read-only
                .Where(p => p.Price > q.MinPrice)
                .Select(p => new ProductDto(p.Id, p.Name, p.Price))
                .ToListAsync(ct);
                
            return new Result(products);
        }
    }
}
```

#### Commands (Write)

```csharp
// Core/Features/Products/Commands/CreateProduct.cs
namespace SourceBackend.Core.Features.Products.Commands;

public static class CreateProduct
{
    public sealed record Command(string Name, decimal Price);
    public sealed record Result(int Id, DateTimeOffset CreatedAt);

    public sealed class Handler(ApplicationDbContext db, TimeProvider clock)
    {
        public async Task<Result> Handle(Command cmd, CancellationToken ct)
        {
            var product = new Product 
            { 
                Name = cmd.Name, 
                Price = cmd.Price,
                CreatedAt = clock.GetUtcNow()
            };
            
            db.Products.Add(product);
            await db.SaveChangesAsync(ct);  // Save changes
            
            return new Result(product.Id, product.CreatedAt);
        }
    }
}
```

### When to Create a Specific Repository (Optional)

**Only create a specific repository if**:
- You have complex data access logic that repeats across multiple handlers
- You want to test handlers without depending on EF Core in your tests
- The query logic is very domain-specific

**Example of specific repository**:

1. **Interface in Core**:
```csharp
namespace SourceBackend.Core.Abstractions;

public interface IProductRepository
{
    Task<Product?> GetByIdAsync(int id, CancellationToken ct = default);
    Task<IReadOnlyList<Product>> GetActiveProductsAsync(CancellationToken ct = default);
}
```

2. **Implementation in Infrastructure**:
```csharp
namespace SourceBackend.Infrastructure.Data.Repositories;

public sealed class ProductRepository : IProductRepository
{
    private readonly ApplicationDbContext _db;

    public ProductRepository(ApplicationDbContext db)
    {
        _db = db;
    }

    public async Task<Product?> GetByIdAsync(int id, CancellationToken ct = default)
    {
        return await _db.Products.FindAsync(new object[] { id }, ct);
    }

    public async Task<IReadOnlyList<Product>> GetActiveProductsAsync(CancellationToken ct = default)
    {
        return await _db.Products
            .AsNoTracking()
            .Where(p => p.IsActive)
            .OrderBy(p => p.Name)
            .ToListAsync(ct);
    }
}
```

3. **Register in DI (Program.cs)**:
```csharp
builder.Services.AddScoped<IProductRepository, ProductRepository>();
```

## Best Practices

1. **Reads**: Use `.AsNoTracking()` for read-only queries (better performance)
2. **Transactions**: One transaction per use case (automatic with `SaveChangesAsync`)
3. **Projections**: Project to DTOs directly in queries with `.Select()` (don't fetch full entities if not needed)
4. **Explicit Mapping**: Map manually between entities and DTOs (no AutoMapper - rules ยง0)
5. **CancellationToken**: Always propagate in async operations
6. **Configurations**: Use Fluent API in separate configuration classes
7. **KISS/YAGNI**: Use DbContext directly; only create abstractions when you really need them

## Troubleshooting

### Error: "No database provider has been configured"
- Verify that `AddDbContext` is registered in `Program.cs`
- Verify that the connection string is configured

### Error creating migrations
- Make sure to specify both projects: `--project` and `--startup-project`
- Verify that the connection string is in user-secrets or appsettings

### Database connection error
- Verify connection string with `dotnet user-secrets list`
- Verify that SQL Server is accessible
- Review Serilog logs for details
